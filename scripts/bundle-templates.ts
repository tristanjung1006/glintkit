import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT = path.resolve(__dirname, "..");
const TEMPLATES_DIR = path.join(ROOT, "templates");
const OUTPUT_FILE = path.join(ROOT, "src", "registry", "__generated__", "templates.ts");

function getAllFiles(dir: string, base: string = dir): string[] {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  const files: string[] = [];

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...getAllFiles(fullPath, base));
    } else {
      files.push(fullPath);
    }
  }

  return files;
}

function main() {
  if (!fs.existsSync(TEMPLATES_DIR)) {
    console.error("templates/ directory not found");
    process.exit(1);
  }

  const files = getAllFiles(TEMPLATES_DIR);
  const entries: string[] = [];

  for (const filePath of files) {
    const relative = path.relative(TEMPLATES_DIR, filePath);
    // Remove extension to create key
    const ext = path.extname(relative);
    const key = relative.replace(ext, "").replace(/\\/g, "/");
    const content = fs.readFileSync(filePath, "utf-8");

    // Escape backticks and dollar signs for template literal
    const escaped = content.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\$/g, "\\$");
    entries.push(`  "${key}": \`${escaped}\``);
  }

  const output = `// AUTO-GENERATED - DO NOT EDIT
// Generated by scripts/bundle-templates.ts

export const TEMPLATES: Record<string, string> = {
${entries.join(",\n")}
};
`;

  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_FILE);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  fs.writeFileSync(OUTPUT_FILE, output, "utf-8");
  console.log(`✔ Bundled ${files.length} templates → ${path.relative(ROOT, OUTPUT_FILE)}`);
}

main();
